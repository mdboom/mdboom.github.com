<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Boom! Michael Droettboom's blog - mozilla</title><link href="http://droettboom.com/" rel="alternate"></link><link href="http://droettboom.com/feeds/mozilla.atom.xml" rel="self"></link><id>http://droettboom.com/</id><updated>2018-04-04T00:00:00-04:00</updated><entry><title>Scientific Python in the Browser</title><link href="http://droettboom.com/blog/2018/04/04/python-in-the-browser/" rel="alternate"></link><published>2018-04-04T00:00:00-04:00</published><updated>2018-04-04T00:00:00-04:00</updated><author><name>Michael Droettboom</name></author><id>tag:droettboom.com,2018-04-04:/blog/2018/04/04/python-in-the-browser/</id><summary type="html">&lt;p class="first last"&gt;An early report on getting the scientific Python stack compiled to WebAssembly.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;&lt;strong&gt;Summary:&lt;/strong&gt; An early report on getting the scientific Python stack compiled to WebAssembly.&lt;/p&gt;
&lt;div class="section" id="data-science-in-the-browser"&gt;
&lt;h2&gt;Data Science in the Browser&lt;/h2&gt;
&lt;p&gt;Shortly after starting at Mozilla in January, I became aware of Hamilton Ulmer
and Brendan Colloran's &lt;a class="reference external" href="https://github.com/iodide-project/iodide"&gt;Iodide&lt;/a&gt;
project, an experiment to build a data science notebook based on web
technologies. Unlike Jupyter notebooks, the computation happens in the browser,
with direct access to Web API technologies like the DOM. Sharing a notebook is
as simple as passing around a single HTML file, since there's no server side to
worry about. It's not out to replace Jupyter notebooks, but rather to exist in a
different design tradeoff space that makes it more suitable the sharing and
collaboration.&lt;/p&gt;
&lt;p&gt;Since it targets the browser, the programming language of Iodide is, of course,
Javascript. While there are a number of libraries for doing data science in
Javascript, such as &lt;a class="reference external" href="https://github.com/nicolaspanel/numjs"&gt;numjs&lt;/a&gt; and &lt;a class="reference external" href="http://scijs.net/packages/"&gt;scijs&lt;/a&gt;, they aren't as widely used or as battle-tested
as the scientific Python or R ecosystems. Nonetheless, I think &amp;quot;data science in
Javascript&amp;quot; is an interesting area to explore, particularly since Javascript has
some of the best JIT compilers of any dynamic language. This advantage allows
writing both high-level orchestration and low-level numeric code in the same
language, side-stepping the notorious &amp;quot;two language problem&amp;quot; in scientific
Python. (In Python land, most of the core scientific libraries have significant
chunks of code in lower level languages such as C, FORTRAN or &lt;a class="reference external" href="http://cython.org/"&gt;Cython&lt;/a&gt; for performance reasons.) Combining Javascript's great
compiler technology, and perhaps adding a smattering of transpilation to fix
some syntactic issues, is really promising, and Iodide as a project is
exploring that space.&lt;/p&gt;
&lt;p&gt;Nonetheless, we received frequent feedback that Iodide &amp;quot;looks really cool, but I
wish I could use the Python (or R) tools I'm familiar with.&amp;quot; I understood in
theory that it should be possible to compile the Python interpreter into
&lt;a class="reference external" href="http://webassembly.org/"&gt;WebAssembly&lt;/a&gt; in order to run it in the browser.
There are already a few projects that do this: (&lt;a class="reference external" href="https://github.com/dgym/cpython-emscripten"&gt;cpython-emscripten&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/micropython/micropython/pull/3575"&gt;micropython javascript support&lt;/a&gt;, &lt;a class="reference external" href="http://pypyjs.org/"&gt;pypyjs&lt;/a&gt;). Unfortunately, I couldn't find a project that included
a practical scientific Python stack including &lt;a class="reference external" href="http://numpy.org"&gt;Numpy&lt;/a&gt; and
friends. I was concerned about the amount of effort it would take to build such
a thing, and also whether the result would be performant enough to be useful. In
February, we had a conversation with some folks who work on WebAssembly tooling
at Mozilla, and they were pretty bullish that it wouldn't be too hard. Based on
their optimism, I gave it a shot, and starting with dgym's &lt;a class="reference external" href="https://github.com/dgym/cpython-emscripten"&gt;cpython-emscripten&lt;/a&gt; as a basis, I had the basic
parts of a Python interpreter working in WebAssembly in a couple of days. Of
course, going from that to a working Numpy took much longer, but thanks to some
help from Alon Zakai and others, Numpy is working, too. With that done, it has
been much easier getting other libraries higher up the stack to work, including
preliminary support for Pandas.&lt;/p&gt;
&lt;div class="section" id="tight-integration"&gt;
&lt;h3&gt;Tight integration&lt;/h3&gt;
&lt;p&gt;One thing that sets this implementation apart from other Python-in-the-browser
projects I've come across is the ability to easily pass and share objects
between Python and Javascript.&lt;/p&gt;
&lt;p&gt;The basic Python data types (None, bool, int, float, str, bytes, list and dict)
are transparently converted to and from their Javascript equivalents. Other
types, including Numpy arrays, are wrapped in a proxy that allows Javascript to
call their methods and access their items and attributes. Vice versa, Javascript
objects are wrapped in a Python proxy. These proxies allow objects to be
shared on both sides of the language barrier without copying,
which is particularly important for large Numpy arrays.&lt;/p&gt;
&lt;p&gt;Say, for example, you had a value in Javascript:&lt;/p&gt;
&lt;pre class="code javascript literal-block"&gt;
&lt;span class="c1"&gt;// javascript
&lt;/span&gt;&lt;span class="nx"&gt;secret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Wklv#lv#olnh#pdjlf$&amp;quot;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;You could use it from Python by using the &lt;tt class="docutils literal"&gt;from js import ...&lt;/tt&gt; syntax:&lt;/p&gt;
&lt;pre class="code python literal-block"&gt;
&lt;span class="c1"&gt;# python&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;js&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;secret&lt;/span&gt;

&lt;span class="n"&gt;decoded&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;''&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;chr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;ord&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;secret&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;And then send data back to the Javascript side using &lt;tt class="docutils literal"&gt;pyodide.pyimport&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="code javascript literal-block"&gt;
&lt;span class="c1"&gt;// javascript
&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;decoded&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;pyodide&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;pyimport&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;decoded&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;One of the coolest side effects of this design is that Python has complete
access to the Web API, so it can manipulate the DOM, use HTML Canvas, access
webcams or audio and all the other cool things you can do from Javascript in a
browser.&lt;/p&gt;
&lt;p&gt;For example, changing the browser tab's title is as simple as importing
&lt;tt class="docutils literal"&gt;window&lt;/tt&gt; and setting an attribute:&lt;/p&gt;
&lt;pre class="code python literal-block"&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;js&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;window&lt;/span&gt;
&lt;span class="n"&gt;window&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;My mind is blown&amp;quot;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="what-works"&gt;
&lt;h3&gt;What works&lt;/h3&gt;
&lt;p&gt;Most of the Python standard library works. The most notable exceptions are:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;subprocess&lt;/tt&gt;: since the browser isn't an OS, it can't spawn new processes.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;socket&lt;/tt&gt;: access to raw network sockets would break the browser security
model. There are a lot of networking-related things in the standard library
built on &lt;tt class="docutils literal"&gt;socket&lt;/tt&gt; that therefore also don't work.&lt;/li&gt;
&lt;li&gt;All of the browser sandboxing still applies, so you can't access the local
filesystem. However, by calling through Javascript, you do have access to
&lt;tt class="docutils literal"&gt;XMLHttpRequest&lt;/tt&gt; and browser local storage. Eventually, Python wrappers
around this functionality &lt;a class="reference external" href="https://github.com/iodide-project/pyodide/issues/19"&gt;should be written&lt;/a&gt; to make those
operations feel more like they do in native Python.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Within Numpy, all of the core functionality works, but there's no support for
&lt;tt class="docutils literal"&gt;long double&lt;/tt&gt; (but those are pretty niche). There are still some low-level
compiler bugs that prevent the FFT stuff from compiling, but that should
eventually resolve.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="how-fast-is-it"&gt;
&lt;h3&gt;How fast is it?&lt;/h3&gt;
&lt;p&gt;To answer this question, I reached for a few existing Python and Numpy benchmarks:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The venerable &lt;a class="reference external" href="https://svn.python.org/projects/python/trunk/Lib/test/pystone.py"&gt;pystone&lt;/a&gt;,
which ships with CPython.&lt;/li&gt;
&lt;li&gt;Serge Guelton's set of &lt;a class="reference external" href="https://github.com/serge-sans-paille/numpy-benchmarks/"&gt;numpy benchmarks&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These benchmarks probably fall into the trap of being a little too &amp;quot;synthetic&amp;quot;.
I would have preferred to also use the &lt;a class="reference external" href="http://pyperformance.readthedocs.io/index.html"&gt;Python Performance Benchmark Suite&lt;/a&gt;, which aims to be a little
closer to &amp;quot;real world&amp;quot;, but it has a significant number of dependencies and
would need to be adapted to work on a platform without &lt;tt class="docutils literal"&gt;subprocess&lt;/tt&gt; before it
could be used in this context. Nonetheless, I think these benchmarks offer a
useful approximation for now.&lt;/p&gt;
&lt;p&gt;The &lt;a class="reference external" href="https://github.com/iodide-project/pyodide/tree/master/benchmark/benchmarks/"&gt;benchmarks&lt;/a&gt;
were run on the same machine in the native CPython implementation and in Firefox
Nightly using selenium. The following figure shows how many times slower the
WebAssembly implementation is.&lt;/p&gt;
&lt;object data="/images/pyodide-benchmarks.svg" style="width: 800px; height: 800px;" type="image/svg+xml"&gt;
description&lt;/object&gt;
&lt;p&gt;The results are interesting. For benchmarks that spend most of their time in
Numpy routines, such as &lt;a class="reference external" href="https://github.com/iodide-project/pyodide/tree/master/benchmark/benchmarks/harris.py"&gt;harris&lt;/a&gt;
or &lt;a class="reference external" href="https://github.com/iodide-project/pyodide/tree/master/benchmark/benchmarks/rosen.py"&gt;rosen&lt;/a&gt;,
runtime is at par with the native-compiled Python. When WebAssembly rocks, it
really, really rocks. Unfortunately, for other benchmarks that spend a lot of
time looping or making function calls in Python, runtimes can be as much as 35
times slower. I have an unsubstantiated hunch that this is due to the use of
Emscripten's &lt;a class="reference external" href="https://kripken.github.io/emscripten-site/docs/porting/guidelines/function_pointer_issues.html#asm-pointer-casts"&gt;EMULATE_FUNCTION_POINTER_CASTS&lt;/a&gt;
option which is required to make all of the function pointer calls that CPython
does work correctly.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="future-directions"&gt;
&lt;h3&gt;Future directions&lt;/h3&gt;
&lt;p&gt;I'd love to see improvements to the toolchain that close the performance gap. At
this point, I don't personally know enough to anticipate how much work is
involved.&lt;/p&gt;
&lt;p&gt;Another current limitation is that all of the packages you anticipate you might
need must be compiled and wrapped into a single large data file that is
downloaded in its entirety to your browser before anything can start. It would
be great to modularize that, so that packages are downloaded on demand. Related
to that, it would also be helpful to modularize the build system so that
individual packages can be added more independently. &lt;a class="reference external" href="https://github.com/conda/conda-build"&gt;Conda build&lt;/a&gt; could potentially serve as a basis for
that.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="check-it-out"&gt;
&lt;h3&gt;Check it out&lt;/h3&gt;
&lt;p&gt;The easiest way to play with this is to visit the &lt;a class="reference external" href="https://iodide-project.github.io/pyodide-demo/python.html"&gt;example Pyodide notebook&lt;/a&gt; (EDIT: This link
was fixed to a working version). (Note that this only works on Firefox right
now. Chrome support is &lt;a class="reference external" href="https://github.com/iodide-project/pyodide/issues/17"&gt;pending&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;You can also get involved at &lt;a class="reference external" href="https://github.com/iodide-project/pyodide/"&gt;pyodide github repository&lt;/a&gt;. Note that while Pyodide grew
out of the needs of Iodide, there's nothing Iodide-specific about it, and it
should be useful in other contexts where you want to embed a scientific Python
stack in the browser. I'm pretty new to WebAssembly and I'd love any help,
advice or comments to make this better.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="python"></category><category term="data science"></category></entry><entry><title>Jupyter notebooks and version control</title><link href="http://droettboom.com/blog/2018/01/18/diffable-jupyter-notebooks/" rel="alternate"></link><published>2018-01-18T00:00:00-05:00</published><updated>2018-01-18T00:00:00-05:00</updated><author><name>Michael Droettboom</name></author><id>tag:droettboom.com,2018-01-18:/blog/2018/01/18/diffable-jupyter-notebooks/</id><summary type="html">&lt;p class="first last"&gt;Presents an experimental alternative file format for Jupyter notebooks that plays nicer with version control.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;&lt;strong&gt;Summary:&lt;/strong&gt; Presents an experimental alternative file format for Jupyter notebooks that plays nicer with version control.&lt;/p&gt;
&lt;div class="section" id="the-problem"&gt;
&lt;h2&gt;The problem&lt;/h2&gt;
&lt;p&gt;There's no doubt that Jupyter notebooks are taking over the world for data science experimentation.
When notebooks are relied on for ongoing decision-making within an organization, it's inevitable that, like all software, they will require bugfixes or updates.
Without proper version control of these changes, its difficult to know what changes were made, and, more importantly, to reason about what effect those changes may have had on the results.
While you can simply put Jupyter notebooks into a version control system (VCS), such as &lt;a class="reference external" href="http://git-scm.com"&gt;git&lt;/a&gt;, the design of the notebook file format makes certain important operations, like calculating the difference between two revisions, less friendly than they could be.&lt;/p&gt;
&lt;p&gt;For example, the &lt;a class="reference external" href="http://nbformat.readthedocs.io/"&gt;Jupyter notebook file format&lt;/a&gt; contains binary blobs for image output.
The diffs between these sections are large and noisy, and ultimately unhelpful to the software developer reviewing a pull request.
Secondly, since the file format is based on &lt;a class="reference external" href="http://www.json.org"&gt;JSON&lt;/a&gt;, multi-line strings (such as all source code) are full of boilerplate:
Each line is in its own set of double-quotes, with explicit newlines (&lt;tt class="docutils literal"&gt;\n&lt;/tt&gt;).  For example, this Python:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
items = []
for i, item in enumerate(database.all_docs(params={'include_docs' : True})):
    if i &amp;gt; 1: break
    items.append(item)
print items
&lt;/pre&gt;
&lt;p&gt;turns into the following JSON:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;quot;source&amp;quot;: [
  &amp;quot;items = []\n&amp;quot;,
  &amp;quot;for i, item in enumerate(database.all_docs(params={'include_docs' : True})):\n&amp;quot;,
  &amp;quot;    if i &amp;gt; 1: break\n&amp;quot;,
  &amp;quot;    items.append(item)\n&amp;quot;,
  &amp;quot;print items&amp;quot;
]
&lt;/pre&gt;
&lt;p&gt;All of this makes it more difficult to see meaningful changes through all the noise.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="some-solutions"&gt;
&lt;h2&gt;Some solutions&lt;/h2&gt;
&lt;p&gt;I'm by no means the first person to notice these issues, and others have tackled this problem from different directions.&lt;/p&gt;
&lt;p&gt;In the blog post &lt;a class="reference external" href="http://timstaley.co.uk/posts/making-git-and-jupyter-notebooks-play-nice/"&gt;Making Git and Jupyter play nice&lt;/a&gt;, Tim Staley suggests filtering the notebook files to remove the output cells and less important content (such as &lt;tt class="docutils literal"&gt;metadata&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;execution_count&lt;/tt&gt;).
While this goes a long way to removing a lot of the &amp;quot;noise&amp;quot; in diffs, the content is still JSON.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/rossant/ipymd"&gt;ipymd&lt;/a&gt; perhaps comes the closest to solving this problem, in my opinion, by converting notebooks to markdown, with code inserted as standard markdown code blocks.  For example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Here is some Python code:

```python
&amp;gt;&amp;gt;&amp;gt; print(&amp;quot;Hello world!&amp;quot;)
Hello world!
```
&lt;/pre&gt;
&lt;p&gt;It currently has a major shortcoming, in that it doesn't handle non-textual output cells.
Jupyter output cells are more complex than they might appear at first glance, as each can include multiple representations of the same thing, allowing the front-end to ultimately choose the best based on context.
I think there are probably some clever ways that could be resolved, but any solution is likely to be lossy relative to what standard Jupyter notebooks can do, or break strict compatibility with markdown.&lt;/p&gt;
&lt;p&gt;There is also &lt;a class="reference external" href="http://nbdime.readthedocs.io/en/stable/"&gt;nbdime&lt;/a&gt;: a tool designed specifically for diffing and merging Jupyter notebooks.
The advantage of nbdime is that, since it was purpose-built for Jupyter notebooks, the user interface can take advantage of notebook-specific features, such as image diffing.
Unfortunately, it is hard to integrate it into existing code review workflows, like Github pull requests.
Here at Mozilla, for example, many of those doing data science in Jupyter notebooks are Firefox software engineers first and foremost, so they are comfortable and opinionated about the community of &amp;quot;power tools&amp;quot; built around version control: suggesting a single-use tool just for notebooks might be a hard sell.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="yet-another-idea"&gt;
&lt;h2&gt;Yet another idea&lt;/h2&gt;
&lt;p&gt;Given all this, I've experimented with an approach that both allows for better diffs while still retaining all of the information present in a Jupyter notebook.
There are lot of ways it could be done, but in the interest of not inventing entirely new syntax, it turns out you can get a large part of the way to the goal by just using &lt;a class="reference external" href="http://yaml.org"&gt;YAML&lt;/a&gt; instead of JSON, with the following tweaks to the YAML writer:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Always write markdown, source code and text output in &lt;a class="reference external" href="http://www.yaml.org/spec/1.2/spec.html#id2795688"&gt;literal style&lt;/a&gt;.  This avoids the explicit newlines required for multi-line text in JSON.&lt;/li&gt;
&lt;li&gt;Remove any keys that point to empty lists or dictionaries, e.g. a &lt;tt class="docutils literal"&gt;metadata&lt;/tt&gt; entries without any actual metadata.&lt;/li&gt;
&lt;li&gt;Order the keys in a consistent way that makes sense to humans.  For example, for each cell include the &lt;tt class="docutils literal"&gt;cell_type&lt;/tt&gt; first, followed by the content, with less important things like &lt;tt class="docutils literal"&gt;metadata&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;execution_order&lt;/tt&gt; afterward.&lt;/li&gt;
&lt;li&gt;Non-textual output cells are saved externally into a directory of files.
This keeps output out of the diff of the main code in the notebook, but it's still present when the notebook is reloaded.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example, here is a cell with output in this YAML-based format:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
- cell_type: code
  source: |-
    fig, ax = plt.subplots(figsize=(18,10))
    sns.boxplot(df.ARR_DELAY_NEW, df.FL_DATE, ax=ax)
    fig.autofmt_xdate()
  outputs:
  - output_type: display_data
    data:
      text/plain: |-
        &amp;lt;matplotlib.figure.Figure at 0x7f679ad6e190&amp;gt;
      image/png: Exploration of Airline On-Time Performance_files/6ff8d173e4d8a288.png
  metadata:
    collapsed: false
  execution_count: 45
&lt;/pre&gt;
&lt;p&gt;Compare that to the original in standard Jupyter notebook JSON:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{
 &amp;quot;cell_type&amp;quot;: &amp;quot;code&amp;quot;,
 &amp;quot;input&amp;quot;: [
  &amp;quot;fig, ax = plt.subplots(figsize=(18,10))\n&amp;quot;,
  &amp;quot;sns.boxplot(df.ARR_DELAY_NEW, df.FL_DATE, ax=ax)\n&amp;quot;,
  &amp;quot;fig.autofmt_xdate()&amp;quot;
 ],
 &amp;quot;metadata&amp;quot;: {
  &amp;quot;collapsed&amp;quot;: false
 },
 &amp;quot;outputs&amp;quot;: [
  {
   &amp;quot;metadata&amp;quot;: {},
   &amp;quot;output_type&amp;quot;: &amp;quot;display_data&amp;quot;,
   &amp;quot;data&amp;quot;: {
    &amp;quot;text/plain&amp;quot;: [
     &amp;quot;&amp;lt;matplotlib.figure.Figure at 0x7f679ad6e190&amp;gt;&amp;quot;
    ],
    &amp;quot;image/png&amp;quot;: &amp;quot;...BASE64 encoded data removed...&amp;quot;,
   }
  }
 ],
 &amp;quot;execution_count&amp;quot;: 45
},
&lt;/pre&gt;
&lt;p&gt;The result is something that is not quite as user-friendly as the markdown produced by ipymd, but it is fully lossless.
Another nice feature of the design is that converting from this format back to a standard Jupyter notebook is as simple as loading YAML, snarfing the external content back in place, and writing out JSON.  That hopefully bodes well for its future-proofing as Jupyter continues to evolve.&lt;/p&gt;
&lt;p&gt;One problem still present is that markdown cells don't diff very well, since in most cases markdown paragraphs are written as one long continuous line.
Brandon Rhodes has some great suggestions about using &lt;a class="reference external" href="http://rhodesmill.org/brandon/2012/one-sentence-per-line/"&gt;semantic linefeeds&lt;/a&gt; to make prose more easily diffable that would help there, but I don't think that is 100% automatable.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="playing-with-the-idea"&gt;
&lt;h2&gt;Playing with the idea&lt;/h2&gt;
&lt;p&gt;I have an &lt;a class="reference external" href="http://github.com/mdboom/nbconvert_vc"&gt;experimental plugin&lt;/a&gt; for &lt;a class="reference external" href="http://nbconvert.readthedocs.io/"&gt;nbconvert&lt;/a&gt; on Github that implements the conversion to and from this YAML-based format.
As an experiment, I ran the conversion over the entire git history of a collection of Jupyter notebooks put out by &lt;a class="reference external" href="https://github.com/ibm-et/jupyter-samples"&gt;IBM Emerging Technologies&lt;/a&gt;.
(&lt;a class="reference external" href="https://git-scm.com/docs/git-filter-branch"&gt;git filter-branch&lt;/a&gt; is an awesome tool for this exact purpose, by the way.)
Many of the notebooks in this repository have no history (whether that's because versioning Jupyter notebooks is too hard, we may never know), but for those that do have history, there is definitely some useful improvement, for example compare &lt;a class="reference external" href="https://github.com/ibm-et/jupyter-samples/commit/29162a6ed77ccb2ef23cd530f5f028a9e1a3a27c"&gt;before&lt;/a&gt; and &lt;a class="reference external" href="https://github.com/mdboom/jupyter-samples/commit/0060324e6618afa52c571278f86876a60cce2899"&gt;after&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;My main purpose of this blog post is just to solicit feedback on these ideas as I work toward a solution for better support for version control workflows with Jupyter notebooks.
Please leave comments, suggestions and questions below.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="acknowledgements"&gt;
&lt;h2&gt;Acknowledgements&lt;/h2&gt;
&lt;p&gt;This work was supported by &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;moz://a&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
</content><category term="jupyter"></category><category term="python"></category><category term="data science"></category></entry></feed>